# DACS v2 인터페이스 문서

> **wiiiv Canonical Document**

---

## 문서 메타데이터

| 항목 | 내용 |
|------|------|
| 문서명 | DACS v2 인터페이스 정의서 |
| 버전 | v2.1 |
| 상태 | **Canonical** |
| 작성일 | 2026-01-28 |
| 수정일 | 2026-01-30 |
| 상위 문서 | Governor 역할 정의서 v1.1, Spec 정의서 v1.0 |
| 적용 범위 | wiiiv DACS 모듈 전반 |
| 변경 사항 | v2.1: Spec 해석 규칙 및 결과 처리 규칙 추가 |

---

## 0. 문서의 위상

이 문서는 wiiiv에서 DACS의 **역할·책임·출력 한계**를 규정한다.

- **DACS는 판단 주체가 아니다**
- **DACS는 흐름을 제어하지 않는다**
- **DACS는 합의 결과만 반환한다**
- **DACS의 결과 해석 및 다음 행동 결정은 Governor의 책임이다**

> 이 문서를 벗어나는 DACS 구현은 **기능 추가가 아니라 설계 위반**이다.

---

## 1. DACS v2의 정의

**DACS (Dynamic Agent Consensus System) v2**는 wiiiv에서 사용되는 **다중 페르소나 합의 엔진**이다.

DACS v2의 유일한 목적은 다음 질문에 답하는 것이다:

> **"이 Spec에 대해, 합의된 관점에서 실행을 허용할 수 있는가?"**

---

## 2. DACS v2의 역할 (What DACS Does)

DACS v2는 다음 역할**만** 수행한다:

1. 다중 페르소나(LLM)를 호출한다
2. 동일한 Spec을 서로 다른 관점에서 검토한다
3. 의견을 종합하여 합의 상태를 도출한다
4. 그 결과를 정형화된 출력으로 반환한다

**DACS는:**
- 실행하지 않는다
- 다음 단계를 지시하지 않는다
- 사용자와 직접 대화하지 않는다
- Gate를 호출하지 않는다

---

## 3. DACS v2가 하지 않는 것 (What DACS Does NOT Do)

DACS v2는 다음을 **절대 하지 않는다**:

```
❌ 흐름 결정
❌ 상태 전이 관리
❌ 반복 호출 판단
❌ 사용자 승인 판단
❌ 실행 허용/거부 결정
❌ Gate 우회
❌ Spec 수정
❌ Spec 보완 요청
❌ Blueprint 생성
❌ 실행 지시
```

> **DACS는 의견 제공자이며, 지휘자도, 판사도 아니다.**

---

## 4. 입력 인터페이스

### 4.1 입력 형식

DACS v2는 반드시 **Spec 단위**로만 호출된다.

```json
{
  "type": "DACS_REQUEST",
  "spec": {
    "...": "실행 대상 Spec"
  },
  "context": "선택적. Governor가 제공하는 판단 맥락"
}
```

### 4.2 입력 규칙

- Spec은 **"무엇을 할 것인지"**를 기술해야 한다
- **"어떻게 할 것인지"**는 필수 아님
- Spec이 불완전해도 호출은 가능하다 (단, 결과는 REVISION이 될 가능성이 높다)

### 4.3 Spec 전달 규칙 (v2.1 추가)

Governor가 판단을 DACS에 위임하는 경우:

| 규칙 | 허용 |
|------|------|
| Spec 전체를 그대로 전달 | ✅ |
| 요약본만 전달 | ❌ |
| 일부 발췌본만 전달 | ❌ |

DACS는 Spec을 다음과 같이 취급한다:

> **Spec은 판단의 대상이지, 수정 가능한 문서가 아니다.**

---

## 5. 내부 페르소나 구성 (참고)

> ⚠️ 이 섹션은 **구현 가이드**이며, 외부 인터페이스가 아니다.

DACS v2는 내부적으로 다음 페르소나를 사용한다:

| 페르소나 | 관점 |
|----------|------|
| **Architect** | 구조적 타당성 |
| **Reviewer** | 요구사항 충족 여부 |
| **Adversary** | 위험, 보안, 악용 가능성 |

각 페르소나는:
- 동일한 Spec을 입력으로 받는다
- 독립적으로 평가한다
- 서로의 결과를 알지 못한다

---

## 6. 출력 인터페이스 (핵심)

### 6.1 출력 형식 (고정)

```json
{
  "consensus": "YES | NO | REVISION",
  "reason": "합의에 도달한 핵심 이유 요약"
}
```

DACS는 반드시 **YES, NO, REVISION** 세 가지 결과 중 하나만 반환한다.

이 외의 결과 타입은 **허용되지 않는다.**

### 6.2 consensus 값의 의미

#### YES

- 현재 Spec 상태로 **실행 가능**
- 구조적·논리적·위험 측면에서 수용 가능

YES는 다음을 의미한다:

> **"이 Spec을 근거로 Blueprint를 생성하는 것에 합의한다."**

| 규칙 | 설명 |
|------|------|
| 조건부 여부 | YES는 **조건부가 아니다** |
| 추가 요구 | YES 이후 추가 요구 사항은 **존재하지 않는다** |

> ⚠️ **YES ≠ 실행 허가**
> 실행 여부는 Governor 판단 + Gate 통과에 달려 있다.

---

#### NO

- 현재 Spec은 **실행 불가**
- 위험, 구조 결함, 목적 불명확 등의 이유 존재
- Spec 자체가 부적절하거나 요청이 명백히 허용 불가

NO는 다음을 의미한다:

> **"이 Spec을 근거로 한 실행은 허용될 수 없다."**

**NO 이후 처리 규칙:**

| 행동 | 허용 |
|------|------|
| 해당 Spec으로 Blueprint 생성 | ❌ |
| 동일 Spec 보완 후 재시도 | ❌ |
| 완전히 새로운 Spec으로 새 요청 시작 | ✅ (별개 흐름) |

> Governor는 NO를 우회할 수 없다.
> 완전히 새로운 Spec을 작성하여 새 요청을 시작하는 것은 가능하지만, 이는 기존 흐름의 연장이 아니라 **별개의 흐름**이다.

---

#### REVISION

- Spec의 **보완 또는 명확화** 필요
- 실행 자체는 부정하지 않음
- 정보 부족, 범위 불명확, 조건 미정 등

**REVISION은 가장 중요한 상태다.**

REVISION은 다음을 **의미한다**:

> **"현재의 Spec은 판단에 충분하지 않다."**

REVISION은 다음을 **의미하지 않는다**:

| 오해 | 실제 |
|------|------|
| 부분 승인 | ❌ |
| 조건부 승인 | ❌ |
| 거의 YES | ❌ |

> **REVISION은 중립 상태이며, 승인도 거부도 아니다.**

---

## 7. REVISION 결과 처리 규칙 (v2.1 추가)

### 7.1 REVISION의 반환 형식

REVISION 결과에는 반드시 다음이 포함되어야 한다:

| 항목 | 필수 | 설명 |
|------|------|------|
| REVISION 사유 (reason) | ✅ | 판단 불가능 또는 불충분한 지점의 설명 |

**DACS는 "무엇을 고쳐라"를 지시하지 않는다.**
단지 **"왜 지금은 판단할 수 없는가"**를 설명한다.

### 7.2 REVISION 이후의 책임 분리

REVISION 이후의 흐름은 다음과 같이 고정된다:

```
DACS → 더 이상 관여하지 않음
         ↓
Governor → REVISION 사유를 해석
         ↓
Governor → Spec 보완 또는 추가 질문 진행
         ↓
(선택) → 다시 DACS 호출
```

| 주체 | 책임 |
|------|------|
| DACS | 사유 반환 후 종료 |
| Governor | 사유 해석, Spec 보완/질문, 재호출 판단 |

> **REVISION 이후의 모든 행위 책임은 Governor에게 있다.**

### 7.3 REVISION과 Blueprint 생성

| DACS 결과 | Blueprint 생성 |
|-----------|---------------|
| YES | ✅ 가능 |
| REVISION | ❌ 불가 |
| NO | ❌ 불가 |

> **REVISION 상태에서는 Blueprint를 생성해서는 안 된다.**

---

## 8. DACS 결과와 Spec 생애주기

### 8.1 Spec 흐름에서 DACS의 위치

```
Spec 생성
  → Governor 판단
    → (선택) DACS 검증
      → YES → Blueprint 생성
      → REVISION → Spec 보완 → 다시 DACS 호출
      → NO → 종료
```

### 8.2 DACS의 역할 한정

DACS는 이 흐름에서:

- 판단을 **대체하지 않으며**
- 실행을 **통제하지 않고**
- 판단의 **안전장치 역할만** 수행한다

DACS의 출력은 **판단 결과에 대한 신호(signal)**이며,
그 해석과 후속 조치는 **Governor의 책임**이다.

---

## 9. Governor ↔ DACS 책임 경계

| 항목 | Governor | DACS |
|------|:--------:|:----:|
| 호출 시점 결정 | ✅ | ❌ |
| Spec 전체 전달 | ✅ | - |
| Spec 보완 여부 | ✅ | ❌ |
| 합의 수행 | ❌ | ✅ |
| 합의 결과 해석 | ✅ | ❌ |
| REVISION 사유 해석 | ✅ | ❌ |
| 실행 여부 판단 | ✅ | ❌ |
| Blueprint 생성 | ✅ | ❌ |
| Gate 통과 | ❌ | ❌ |

> **합의는 DACS, 판단은 Governor**

---

## 10. 반복 호출에 대한 규칙

- DACS는 **상태를 기억하지 않는다**
- 동일한 Spec에 대해 여러 번 호출될 수 있다
- 반복 호출 여부 판단은 **Governor 책임**이다

DACS는 다음을 신경 쓰지 않는다:
- "이미 검토했는가?"
- "몇 번째 호출인가?"

---

## 11. 오류 및 예외 처리

| 상황 | 처리 |
|------|------|
| DACS 내부 오류 | Governor에게 오류 전달 |
| 타임아웃 | 합의 실패로 처리 (NO 또는 REVISION 권장) |
| 페르소나 일부 실패 | 가능한 범위에서 합의 시도 |

> 오류 처리 정책 역시 **Governor가 해석하고 판단**한다.

---

## 12. 설계 원칙 요약

```
DACS는 합의 엔진이다
DACS는 흐름을 모른다
DACS는 실행을 모른다
DACS는 결과만 반환한다
DACS는 Spec을 수정하지 않는다
DACS는 Governor의 판단을 대체하지 않는다
REVISION은 승인도 거부도 아니다
REVISION 이후 책임은 Governor에게 있다
YES만 Blueprint 생성을 허용한다
```

---

## 13. 최종 선언

**DACS v2는 wiiiv의 윤리적·구조적 안전 장치다.**

그러나 **DACS는 wiiiv의 지휘자가 아니다.**

wiiiv의 흐름을 지휘하는 것은 **오직 Governor**다.

이 문서에서 정의된 Spec / REVISION 해석 규칙을 벗어나는 DACS 동작은
**확장이 아니라 설계 위반**이다.

---

## Canonical 상태 요약

| 구성 요소 | 상태 |
|-----------|------|
| Governor 역할 정의서 v1.1 | ✅ Canonical |
| Spec 정의서 v1.0 | ✅ Canonical |
| DACS v2 인터페이스 v2.1 | ✅ Canonical |
| Gate 최소 스펙 정의서 v1.0 | ✅ Canonical |
| Blueprint Spec v1.1 | ✅ Canonical |
| Blueprint Structure Schema v1.0 | ✅ Canonical |
| Blueprint Node Type Spec v1.0 | ✅ Canonical |

---

## Spec 축 완결 선언

이 문서로 **Spec 축의 설계가 완결**되었다:

- **Spec**: 판단 자산의 정의
- **Governor**: Spec 충분성 판단 책임
- **DACS**: Spec 기반 합의 및 결과 해석 규칙
- **Blueprint**: Spec 스냅샷 고정 규칙

> **Spec은 이제 "설계 대상"이 아니라 "운영되는 자산"이다.**

---

*wiiiv / 하늘나무 / SKYTREE*
